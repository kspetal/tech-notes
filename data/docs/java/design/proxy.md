---
sidebar_position: 1
---

# 代理模式

### 示例: 叫个代驾
> https://juejin.cn/post/7490398244154916901?utm_source=gold_browser_extension


从一个引子开始：司机和代驾。「私家车司机」和「代驾」是什么关系？很简单，「私家车司机」是客户，「代驾」负责提供服务，帮他们开车。

- **不同点:**
  
「私家车司机」有自己的车，他们可能自己开车，也可能找代驾开车；

「代驾」没有自己的车，但他们会接到代驾订单，从而开「私家车司机」的车。

- **相同点:**

他们都会开车，有驾照。换句话说，他们都属于「司机」。

说到这里，我想他们的关系就很清楚了：「司机」是「私家车司机」和「代驾」的父类。虽然都会开车，但他们对“开车”这个行为有不同的实现。

#### 用类关系表示
首先定义一个抽象类「司机」，就叫Driver好了：
``` java
@Data
public abstract class Driver {

    String name;

    abstract void driveCar();
}
```
我们要求每个司机都有一个名字，且都必须会开车。

接下来看看「私家车司机」，CommonDriver类：
``` java
@Data
public class CommonDriver extends Driver {

    CommonDriver(String name) {
        this.name = name;
    }

    @Override
    public void driveCar() {
        System.out.println(this.getName() + "的汽车正在行驶...");
    }
}
```

也很简单，每次开车的时候打印一行日志即可。最后看看「代驾」，就叫ProxyDriver吧：

``` java
@Data
public class ProxyDriver extends Driver {

    private Driver realDriver;

    ProxyDriver(String name, Driver realDriver) {
        this.name = name;
        this.realDriver = realDriver;
    }

    @Override
    void driveCar() {
        System.out.printf("代驾「%s」正在为%s服务...\n", this.getName(), this.getRealDriver().getName());
        this.realDriver.driveCar();
    }
}
```

我们要求每个代驾都要有一个服务的客户，也就是被代理的司机。我们将这位被代理的司机——realDriver作为了代驾类的私有变量存起来。当代驾在开车时，他实际上开的是客户的车。因此，他直接去调用realDriver的开车方法即可。
三个类定义好了，让我们先创建一个「私家车司机」——小张，让小张自己开车；再帮他叫一个「代驾」——就叫他小代吧，让小代帮他开车
运行一下：
> 小张的汽车正在行驶... 代驾小代正在为小张服务... 小张的汽车正在行驶...

结果符合预期：不管是谁在开车，结果都是一样的，开的都是小张的汽车。

### 代理模式的定义

`代理模式（Proxy Pattern）` 的定义是：**使用代理以代替对真实对象的访问**。 它属于一种结构型设计模式。它属于一种结构型设计模式。

例子中的「司机」、「私家车司机」和「代驾」三个角色，分别对应了代理模式中的三个基本元素：

- `私家车司机`——**真实主题**： 被代理的角色，是业务逻辑的具体执行者。


- `代驾`——**代理主题**： 负责代理真实主题，所有对其业务方法的调用，都会被委托给其真实主题实现。


- `司机`——**抽象主题**： 可以是接口，也可以是抽象类。代理主题和真实主题都会去实现/继承同一个抽象主题。

#### 优点和应用

> 代理模式的优点就在于通过代理间接访问真实对象。通过间接访问，我们就可以让代理做许多中间操作，通过这些中间操作，我们就可以在不修改真实对象的前提下，实现功能增强。

一些常见的应用场景：
- （1）「日志代理」： 让代理帮忙记录方法出入参、调用记录等等日志；

- （2）「保护代理」： 让代理帮忙做权限控制，拦截异常访问，保护真实对象；

- （3）「缓存代理」： 让代理帮忙缓存真实对象的调用结果，从而减少对真实对象的调用量；

- （4）「虚拟代理」： 延迟真实对象的初始化直到真正需要时，从而提高应用的启动速度和运行效率，多用于创建一个对象需要消耗大量资源时，也被称作“懒加载”。

这里，就可以感到代理模式的强大了，代理模式的优点：


- （1）职责清晰： 前面提到，作为真实主题的一种“增强”，代理与真实主题的职责划分十分清晰，这有利于维持真实主题的简洁，让真实主题专注于处理核心逻辑。

- （2）高扩展性： 正因为职责清晰，代理与真实主题是松耦合的，对任何一方的修改都不会对另一方造成影响，适合业务逻辑需要经常扩展的场景。

### 强制代理

列如这天小张喝醉了, 今天这车必须要让代驾开了。强制代理的定义是：对真实对象的访问，必须通过特定的代理对象进行。这句话包含了两层含义：

1. 不允许对真实对象的直接访问。
2. 必须通过特定的代理访问真实对象。